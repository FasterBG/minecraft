#include <iostream>
#include <cstdlib>
#include <ctime>
#include <windows.h>
#include <winuser.h>
#include <stdlib.h>

using namespace std;

const int SCREEN_WIDTH=64;
const int SCREEN_HEIGHT=64;
const int UI_WIDTH = 16;
char screen[SCREEN_WIDTH][SCREEN_HEIGHT];
const char border_ch='*';

const char steve_ch='o';
int steve_r, steve_c;

const int MAX_TREES=5;
const int MAX_STONES=20;
const int MAX_ZOMBIES=5;
const char tree_ch=194;
const char stone_ch=254;
const char zombie_ch = '&';
const char cobblestone_ch = '#';
const char wood_ch = '=';

bool end_game=false;

const int MAX_TREE_HEALTH = 3;
const int MAX_STONE_HEALTH = 5;
const int MAX_ZOMBIE_HEALTH = 2;
const int MAX_COBBLESTONE_HEALTH = 3;
const int MAX_WOOD_HEALTH = 2;
int health_map[SCREEN_HEIGHT][SCREEN_WIDTH];
int steveDirection;
/*
0 = UP
1 = DOWN
2 = LEFT
3 = RIGTH
*/

const int pole_rows = SCREEN_HEIGHT;
const int pole_cols = SCREEN_WIDTH + UI_WIDTH;

int wood_inventory = 0;
int stone_inventory = 0;

int movedZombiesR[MAX_ZOMBIES], movedZombiesC[MAX_ZOMBIES];
int counterForMovedZombies = 0;

HANDLE hConsoleOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);
COORD screen_buf = {pole_cols, pole_rows};
CHAR_INFO blank_screen[(pole_rows) * (pole_cols)] = {0};

enum COLORS {
    BLACK = 0,
    BLUE = FOREGROUND_BLUE,
    CYAN = FOREGROUND_BLUE | FOREGROUND_GREEN,
    GREEN = FOREGROUND_GREEN,
    RED = FOREGROUND_RED,
    BROWN = FOREGROUND_RED | FOREGROUND_GREEN,
    PURPLE = FOREGROUND_RED | FOREGROUND_BLUE,
    LIGHT_GREY =  FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,

    GREY = 0 | FOREGROUND_INTENSITY,
    LIGHT_BLUE = FOREGROUND_BLUE | FOREGROUND_INTENSITY,
    LIGHT_CYAN = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY,
    LIGHT_GREEN = FOREGROUND_GREEN | FOREGROUND_INTENSITY,
    LIGHT_RED = FOREGROUND_RED | FOREGROUND_INTENSITY,
    YELLOW = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY,
    PINK = FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY,
    WHITE =  FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY
};

const COLORS backgroundColor = LIGHT_GREEN;

void draw_char(char ch, int y, int x, COLORS foreground_color, COLORS background_color) {
    CHAR_INFO ch_info;
    ch_info.Char.AsciiChar = ch;
    ch_info.Attributes = foreground_color | (background_color << 4);

    COORD buf_size = {1, 1};
    COORD buf_coord = {0, 0};
    SMALL_RECT screen_pos = {x, y, x+1, y+1};
    ::WriteConsoleOutput(hConsoleOutput, &ch_info, buf_size, buf_coord, &screen_pos);

}

void clear_screen() {
    COORD buf_coord = {0, 0};
    SMALL_RECT screen_pos = {0, 0, screen_buf.X, screen_buf.Y};
    ::WriteConsoleOutput(hConsoleOutput, blank_screen, screen_buf, buf_coord, &screen_pos);
}

void set_background() {
    for (int i = 0; i < screen_buf.X; i++) {
        for (int j = 0; j < screen_buf.Y; j++) {
             draw_char(' ', j, i, BROWN, backgroundColor);
        }
    }
}

void init_console(){

    SMALL_RECT rect = {0, 0, screen_buf.X, screen_buf.Y};

    ::SetConsoleScreenBufferSize(hConsoleOutput, screen_buf);
    ::SetConsoleWindowInfo(hConsoleOutput, TRUE, &rect);
    ::SetConsoleTitle("MINECRAFT");
    set_background();

}

void draw_str(char* str, int r, int c){
    for(int i = 0; str[i]!='\0'; i++){
        draw_char(str[i], r, c + i, BLACK, backgroundColor);
    }
}

void moveZombie(int zombie_r, int zombie_c){
    // Variable: Should we move or not
    bool shouldMove = rand() % 2;
    // For: Checking if the zombie was moved
    for(int i = 0; i < MAX_ZOMBIES; i++){
        if(zombie_r == movedZombiesR[i] && zombie_c == movedZombiesC[i]){
            shouldMove = false;
        }
    }
    if(shouldMove){
        int direction = rand() % 4;
        int n_r = zombie_r, n_c = zombie_c;
        int zombie_health = health_map[zombie_r][zombie_c];
        if(direction == 0){
            // UP
            n_r--;
        }else if(direction == 1){
            // DOWN
            n_r++;
        }else if(direction == 2){
            // RIGTH
            n_c++;
        }else if(direction == 3){
            // LEFT
            n_c--;
        }
        if(screen[n_r][n_c] == '\0'){
            screen[n_r][n_c] = zombie_ch;
            draw_char(zombie_ch, n_r, n_c, GREEN, backgroundColor);
            screen[zombie_r][zombie_c] = '\0';
            draw_char('\0', zombie_r, zombie_c, GREEN, backgroundColor);
            health_map[n_r][n_c] = zombie_health;
            health_map[zombie_r][zombie_c] = 0;
            movedZombiesR[counterForMovedZombies] = n_r;
            movedZombiesC[counterForMovedZombies] = n_c;
            counterForMovedZombies++;
        }
    }
}

void moveMobs(){
    // For: restarting the arrays for moved zombies
    for (int i = 0; i < MAX_ZOMBIES; i++){
        movedZombiesR[i] = false;
        movedZombiesC[i] = false;
    }
    // Restarting the counter
    counterForMovedZombies = 0;
    for(int r = 0; r < SCREEN_HEIGHT; r ++){
        for(int c = 0; c < SCREEN_WIDTH; c ++){
            if(screen[r][c] == zombie_ch){
                moveZombie(r, c);
            }
        }
    }
}

void checkForBuilding(char blockType, int blockHealth, int& needMaterial, char inputButton){
    if(GetAsyncKeyState(inputButton) && needMaterial > 0){
        int block_r = steve_r, block_c = steve_c;
        if(steveDirection == 0){
            block_c++;
        }else if(steveDirection == 1){
            block_c--;
        }else if(steveDirection == 2){
            block_r--;
        }else if(steveDirection == 3){
            block_r++;
        }
        if(screen[block_r][block_c] == '\0'){
            screen[block_r][block_c] = blockType;
            draw_char(blockType, block_r, block_c, GREY, backgroundColor);
            health_map[block_r][block_c] = blockHealth;
            needMaterial--;
        }
    }
}

void moveSteve(){
    int n_r=steve_r, n_c=steve_c;
    if (GetAsyncKeyState('D')) {
        n_c++;
        steveDirection = 0;
    }
    else if (GetAsyncKeyState('A')) {
        n_c--;
        steveDirection = 1;
    }
    else if (GetAsyncKeyState('W')) {
        n_r--;
        steveDirection = 2;
    }
    else if (GetAsyncKeyState('S')) {
        n_r++;
        steveDirection = 3;
    }

    if (screen[n_r][n_c]=='\0'){
        screen[n_r][n_c]=steve_ch;
        draw_char(steve_ch, n_r, n_c, BLACK, backgroundColor);
        screen[steve_r][steve_c]='\0';
        draw_char('\0', steve_r, steve_c, BLACK, backgroundColor);
        steve_r=n_r;
        steve_c=n_c;
    } else if (health_map[n_r][n_c]>1){
        health_map[n_r][n_c]--;
    }else if (health_map[n_r][n_c] == 1){
        if(screen[n_r][n_c] == tree_ch){
            screen[n_r][n_c]='\0';
            draw_char('\0', n_r, n_c, BLACK, backgroundColor);
            wood_inventory++;
        }else if(screen[n_r][n_c] == stone_ch){
            screen[n_r][n_c] = '\0';
            draw_char('\0', n_r, n_c, BLACK, backgroundColor);
            stone_inventory++;
        }else if(screen[n_r][n_c] == cobblestone_ch){
            screen[n_r][n_c] = '\0';
            draw_char('\0', n_r, n_c, BLACK, backgroundColor);
            stone_inventory++;
        }else if(screen[n_r][n_c] == wood_ch){
            screen[n_r][n_c] = '\0';
            draw_char('\0', n_r, n_c, BLACK, backgroundColor);
            wood_inventory++;
        }
    }
}

void add_static_blocks(const int max_count, const char ch, const int health, COLORS infront, COLORS background){
    int br=0, r, c;
    while (br<max_count){
        r=rand()%SCREEN_HEIGHT;
        c=rand()%SCREEN_WIDTH;
        if (screen[r][c]=='\0'){
            screen[r][c]=ch;
            draw_char(ch, r, c, infront, background);
            health_map[r][c]=health;
            br++;
        }
    }
}

void init(){
    for (int r=0; r<SCREEN_HEIGHT; r++){
        screen[r][0]=border_ch;
        draw_char(border_ch, r, 0, BLACK, backgroundColor);
        health_map[r][0]=-1;
        screen[r][SCREEN_WIDTH-1]=border_ch;
        draw_char(border_ch, r, SCREEN_WIDTH-1, BLACK, backgroundColor);
        health_map[r][SCREEN_WIDTH-1]=-1;
    }
    for (int c=0; c<SCREEN_WIDTH; c++){
        screen[0][c]=border_ch;
        draw_char(border_ch, 0, c, BLACK, backgroundColor);
        health_map[0][c]=-1;
        screen[SCREEN_HEIGHT-1][c]=border_ch;
        draw_char(border_ch, SCREEN_HEIGHT-1, c, BLACK, backgroundColor);
        health_map[SCREEN_HEIGHT-1][c]=-1;
    }
    for (int i = 0; i < MAX_ZOMBIES; i++){
        movedZombiesC[i] = false;
        movedZombiesR[i] = false;
    }
    srand(time(NULL));
    int r, c;
    do {
        r=rand()%SCREEN_HEIGHT;
        c=rand()%SCREEN_WIDTH;
        if (screen[r][c]=='\0'){
            screen[r][c]=steve_ch;
            draw_char(steve_ch, r, c, BLACK, backgroundColor);
            steve_r=r;
            steve_c=c;
        }
    } while (screen[r][c]!=steve_ch);

    add_static_blocks(MAX_TREES, tree_ch, MAX_TREE_HEALTH, BROWN, backgroundColor);
    add_static_blocks(MAX_STONES, stone_ch, MAX_STONE_HEALTH, GREY, backgroundColor);
    add_static_blocks(MAX_ZOMBIES, zombie_ch, MAX_ZOMBIE_HEALTH, GREEN, backgroundColor);
}

void UpdateInventory(){
    {
    char buff[32];
    itoa(wood_inventory, buff, 10);
    draw_str("WOOD(F):", 0, SCREEN_WIDTH + 4);
    draw_str(buff, 0, SCREEN_WIDTH + 13);
    }
    {
    char buff[32];
    itoa(stone_inventory, buff, 10);
    draw_str("STONE(G):", 1, SCREEN_WIDTH + 3);
    draw_str(buff, 1, SCREEN_WIDTH + 13);
    }
}

int main(){
    init_console();
    init();
    while (!end_game){
        moveSteve();
        moveMobs();
        checkForBuilding(cobblestone_ch, MAX_COBBLESTONE_HEALTH, stone_inventory, 'F');
        checkForBuilding(wood_ch, MAX_WOOD_HEALTH, wood_inventory, 'G');
        UpdateInventory();
        Sleep(200);
    }
    return 0;
}
